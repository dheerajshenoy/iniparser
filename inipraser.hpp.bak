#include <string>
#include <vector>
#include <fstream>
#include <iostream>
#include <regex>

using namespace std;

class iniparser {

    public:
        bool isfile = false;
        fstream f;
        string line, brackets;
        char delimiters;
        vector<string> all, sections, allkeys, temp;
    
    // OPEN THE INI FILE. ALSO MENTION THE TYPE OF BRACKETS FOR SECTION
    void Open(string path, string bracket="[]", char delimiter='=') {
        if(bracket == "" || bracket == " ")
            return;
        f.open(path, ios::in);
        brackets = bracket;
        delimiters = delimiter;
        isfile = true;
        while(getline(f, lie))
            if(line != "")
                all.push_back(line);
    }

    // GET ALL THE SECTIONS
    vector<string> Sections() {
        if(!isfile)
            return {};
        filereload();
        while(getline(f, line)){
            if(line.find(brackets) != string::npos && line.find(brackets) != string::npos)
                sections.push_back(line);
        }
        return sections;
    }

    // GET ALL THE KEYS
    vector<string> Allkeys() {
        if(!isfile)
            return {};
        filereload();
        while(getline(f, line)){
            if(line.find(brackets[0]) == string::npos && line != "")
                allkeys.push_back(line);        
        }
        return allkeys;
    }

    // GET VALUE OF KEY FROM SECTION MENTIONED WITHOUT BRACKETS
    string GetValue(string key, string section) {
        if(!isfile)
            return "";
        while(getline(f, line)) {
            if(line == brackets[0] + section + brackets[1]) {
                do {
                    getline(f, line);
                } while(line[0] != brackets[0]);
            }
        }
    }

    // TRUE IF THE KEY EXISTS IN THE SECTION
    bool isKey(string key, string section) {
        if(!isfile)
            return false;
        while(getline(f, line)) {
            if(line == brackets[0] + section + brackets[1]) {
                while(getline(f, line)) {
                    if(line[0] == brackets[0])
                        break;
                    else if(line != "") {
                        line.erase(remove_if(line.begin(), line.end(), ::isspace), line.end());
                        temp = split(line, delimiters);
                        if(temp.at(0) == key)
                            return true;
                    }
                }
            }
        }
    return false;
    }

    protected:
    void filereload() {
        if(!isfile)
            return;
        f.clear();
        f.seekg(0, ios::beg);
    }

    vector<string> split(const string &str, const char &ch) {
        
        string next;
        vector<string> result;

        // For each character in the string
        for (string::const_iterator it = str.begin(); it != str.end(); it++) {
            // If we've hit the terminal character
            if (*it == ch) {
                // If we have some characters accumulated
                if (!next.empty()) {
                    // Add them to the result vector
                    result.push_back(next);
                    next.clear();
                }
            } else {
                // Accumulate the next character into the sequence
                next += *it;
            }
        }
        if (!next.empty())
             result.push_back(next);
        return result;
    }
};
